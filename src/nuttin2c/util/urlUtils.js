import { List } from "coreutil_v1";
import { Url } from "./url.js";

export class UrlUtils {

    /**
     * Parse string to url
     * @param {string} urlString 
     * @returns {Url}
     */
    static parse(urlString) {

        if (urlString === null) { return null; }

        const protocol =     UrlUtils.parseProtocol(urlString);
        const host =         UrlUtils.parseHost(urlString);
        const port =         UrlUtils.parsePort(urlString);
        const pathsList =    UrlUtils.parsePathArray(urlString);
        const queryParam =   UrlUtils.parseQueryParam(urlString);
        const bookmark =     UrlUtils.parseBookmark(urlString);

        return new Url(protocol, host, port, pathsList, queryParam, bookmark);
    }

    /**
     * @param {String} urlString 
     * @returns {String}
     */
    static parseProtocol(urlString) {
        if (urlString === null) { return null; }
        if (urlString.indexOf("//") === -1) {
            return null;
        }

        const protocol = urlString.split("//")[0];
        if (protocol[protocol.length - 1] !== ":") {
            return null;
        }
        return protocol;
    }

    /**
     * 
     * @param {String} urlString 
     * @returns {String}
     */
    static parseHost(urlString) {
        if (urlString === null) { return null; }
        if (urlString.indexOf("://") === -1) {
            return null;
        }
        let hostAndPort = urlString.split("://")[1];
        if (hostAndPort.indexOf("/") !== -1) {
            hostAndPort = hostAndPort.split("/")[0];
        }
        let host = hostAndPort;
        if (hostAndPort.indexOf(":") !== -1) {
            host = hostAndPort.split(":")[0];
        }
        return host;
    }

    /**
     * 
     * @param {String} urlString 
     * @returns {Number}
     */
    static parsePort(urlString) {
        if (urlString === null) { return null; }
        if (urlString.indexOf("://") === -1) {
            return null;
        }
        let hostAndPort = urlString.split("://")[1];
        if (hostAndPort.indexOf("/") !== -1) {
            hostAndPort = hostAndPort.split("/")[0];
        }
        if (hostAndPort.indexOf(":") === -1) {
            return null;
        }
        return Number.parseInt(hostAndPort.split(":")[1]);
    }

    /**
     * 
     * @param {String} urlString 
     * @returns {Array<String>}
     */
    static parsePathArray(urlString) {
        if (urlString === null) { return null; }
        if (urlString.indexOf("://") !== -1) {
            urlString = urlString.split("://")[1];
        }
        if (urlString.indexOf("/") !== -1) {
            urlString = urlString.substring(urlString.indexOf("/"));
        }
        if (urlString.indexOf("?") !== -1) {
            urlString = urlString.split("?")[0];
        } else if (urlString.indexOf("#") !== -1) {
            urlString = urlString.split("#")[0];
        }
        if (urlString.startsWith("/")) {
            urlString = urlString.substring(1);
        }
        const rawPathPartList = urlString.split("/");

        const pathValueList = new Array();
        rawPathPartList.forEach((value) => {
            pathValueList.push(decodeURI(value));
        });
        return pathValueList;
    }

    /**
     * 
     * @param {String} urlString 
     * @returns {Map<String, List<String>>}
     */
    static parseQueryParam(urlString) {
        if (urlString === null) { return null; }
        if (urlString.indexOf("://") !== -1) {
            urlString = urlString.split("://")[1];
        }
        if (urlString.indexOf("/") !== -1) {
            urlString = urlString.substring(urlString.indexOf("/"));
        }
        if (urlString.indexOf("?") === -1) {
            return null;
        }
        let queryParam = urlString.split("?")[1];
        if (queryParam.indexOf("#") !== -1) {
            queryParam = queryParam.split("#")[0];
        }
        const paramMap = new Map();
        const paramPairs = queryParam.split("&");
        paramPairs.forEach((pair) => {
            let key = null;
            let value = null;
            if (pair.indexOf("=") !== -1) {
                key = pair.split("=")[0];
                value = pair.split("=")[1];
            } else {
                key = pair;
                value = null;
            }
            key = decodeURI(key);
            value = decodeURI(value);
            if (!paramMap.get(key)) {
                paramMap.set(key, new Array());
            }
            paramMap.get(key).push(value);
        });
        return paramMap;
    }

    static parseBookmark(urlString) {
        if (urlString === null) { return null; }
        if (urlString.indexOf("://") !== -1) {
            urlString = urlString.split("://")[1];
        }
        if (urlString.indexOf("/") !== -1) {
            urlString = urlString.substring(urlString.indexOf("/"));
        }
        if (urlString.indexOf("?") !== -1) {
            urlString = urlString.split("?")[1];
        }
        if (urlString.indexOf("#") === -1) {
            return null;
        }
        let bookmark = urlString.split("#")[1];
        return bookmark;
    }

    static determineProtocol(remaining){
        let value = remaining["string"];

        if (!value) {
            return null;
        }

        let protocol = value;

        if (value.indexOf("//") === -1){
            // No '//' to indicate protocol 
            return null;
        }

        let parts = value.split("//");
        if(parts[0].indexOf("/") !== -1){
            // slash should not be in protocol
            return null;
        }

        protocol = parts[0];
        if (parts.length == 1){
            remaining["string"] = null;
        } else {
            remaining["string"] = value.replace(parts[0] + "//", "");
        }

        return protocol;
    }

    static determineHostAndPort(remaining){
        let value = remaining["string"];

        if (!value) {
            return null;
        }

        let hostAndPort = value;
        let remainingString = null;

        if (hostAndPort.indexOf("/") !== -1) {
            // Host comes before the first '/'
            hostAndPort = hostAndPort.split("/")[0];
            remainingString = value.replace(hostAndPort + "/", "");
        }

        remaining["string"] = remainingString;
        return hostAndPort;
    }

    static extractHost(hostAndPort){
        if (!hostAndPort) {
            return null;
        }
        if(hostAndPort.indexOf(":") === -1){
            return hostAndPort;
        }
        return hostAndPort.split(":")[0];
    }

    static extractPort(hostAndPort){
        if (!hostAndPort) {
            return null;
        }
        if(hostAndPort.indexOf(":") === -1){
            return null;
        }
        return hostAndPort.split(":")[1];
    }

    static determinePath(remaining){
        let value = remaining["string"];

        if (!value) {
            return new List();
        }

        let path = value;

        if (path.indexOf("?") !== -1){
            let parts = path.split("?");
            if (parts.length > 1) {
                remaining["string"] = path.substring(path.indexOf("?"));
            }
            path = parts[0];

        } else if (path.indexOf("#") !== -1){
            let parts = path.split("#");
            if (parts.length > 1) {
                remaining["string"] = path.substring(path.indexOf("#"));
            }
            path = parts[0];

        } else {
            remaining["string"] = null;
        }

        if (path.startsWith("/")) {
            path = value.substring(1);
        }

        const rawPathPartList = new List(path.split("/"));

        const pathValueList = new List();
        rawPathPartList.forEach((value) => {
            pathValueList.add(decodeURI(value));
            return true;
        }, this);

        return pathValueList;
    }

    static determineBookmark(remaining){
        let value = remaining["string"];

        if (!value) {
            remaining["string"] = null;
            return null;
        }

        let bookmark = value;
        if(value.indexOf("#") !== -1) {
            bookmark = value.substring(value.indexOf("#")+1);
            remaining["string"] = null;
        }
        return bookmark;
    }

    static determineQueryParam(remaining){
        let value = remaining["string"];

        if (!value) {
            return null;
        }

        let queryParam = value;
        if(value.indexOf("?") !== -1) {
            queryParam = value.substring(value.indexOf("?")+1);
            remaining["string"] = null;
            if (queryParam.indexOf("#") !== -1) {
                queryParam = queryParam.substring(0, queryParam.indexOf("#"));
                remaining["string"] = queryParam.substring(queryParam.indexOf("#"));
            }
        } else {
            if (queryParam.indexOf("#") !== -1) {
                remaining["string"] = queryParam.substring(queryParam.indexOf("#"));
            }
            return null;
        }
        return queryParam;
    }


}